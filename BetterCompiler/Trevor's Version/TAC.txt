        // FunctionDeclaration
        
        // // FunctionCall
        // case NodeType_FunctionCall: {
        //     // Generate TAC for each argument
        //     TAC* argListTAC = generateTAC(node->functionCall.argList);

        //     instruction->arg1 = argListTAC->result;
        //     instruction->op = "call";
        //     instruction->arg2 = createOperand(node->functionCall.id);
        //     instruction->result = createTempVar();
        //     instruction->nodetype = "FunctionCall";

        //     break;
        // }
        // // ParamList
        // case NodeType_ParamList: {
        //     TAC* paramTailTAC = generateTAC(node->paramList.paramTail);

        //     instruction->arg1 = paramTailTAC->result;
        //     instruction->op = "param";
        //     instruction->arg2 = NULL;
        //     instruction->result = createTempVar();
        //     instruction->nodetype = "ParamList";

        //     break;
        // }
        // // ParamTail
        // case NodeType_ParamTail: {
        //     TAC* paramTAC = generateTAC(node->paramTail.param);
        //     TAC* paramTailTAC = generateTAC(node->paramTail.paramTail);

        //     instruction->arg1 = paramTAC->result;
        //     instruction->arg2 = paramTailTAC->result;
        //     instruction->op = "param";
        //     instruction->result = createTempVar();
        //     instruction->nodetype = "ParamTail";

        //     break;
        // }
        // ArrayDeclaration
        
        // ArrayAccess
        
        // ArrayAssignment. Will need to multiply the index by 4 to get the correct memory location
        
        // // ArgList
        // case NodeType_ArgList: {
        //     TAC* argTailTAC = generateTAC(node->argList.argTail);

        //     instruction->arg1 = argTailTAC->result;
        //     instruction->op = "arg";
        //     instruction->arg2 = NULL;
        //     instruction->result = createTempVar();
        //     instruction->nodetype = "ArgList";

        //     break;
        // }
        // // ArgTail
        // case NodeType_ArgTail: {
        //     TAC* exprTAC = generateTAC(node->argTail.expr);
        //     TAC* argTailTAC = generateTAC(node->argTail.argTail);

        //     instruction->arg1 = exprTAC->result;
        //     instruction->arg2 = argTailTAC->result;
        //     instruction->op = "arg";
        //     instruction->result = createTempVar();
        //     instruction->nodetype = "ArgTail";

        //     break;
        // }













        // Function to create a new temporary variable for TAC
char* createTempVar() {
    static int count = 0;
    char* tempVar = malloc(10); // Enough space for "t" + number
    if (!tempVar) return NULL;
    count = allocateNextAvailableTempVar(tempVars);
    sprintf(tempVar, "t%d", count++);
    return tempVar;
}

int allocateNextAvailableTempVar(int tempVars[]) {
   // implement the temp var allocation logic
   // use the tempVars array to keep track of allocated temp vars

    // search for the next available temp var
    for (int i = 0; i < 60; i++) {
        if (tempVars[i] == 0) {
            tempVars[i] = 1;
            return i;
        }
    }
    return -1; // No available temp var
}



// Function to print all elements of the TAC linked list
void printTAC(TAC* tac) {
    TAC* head = tac;
    if (!head) return;

    cleanupTAC(&head);

    // Print header
    printf("\nRESULT\tARG1\tOP\tARG2\tNodeType\n");

    // Iterate through the linked list using a for loop
    for (TAC* current = head; current != NULL; current = current->next) {
        // Print the fields of the current TAC node, handling null pointers
        if (current->result != NULL)
            printf("%s\t", current->result);
        else
            printf("NULL\t");

        if (current->arg1 != NULL)
            printf("%s\t", current->arg1);
        else
            printf("NULL\t");

        if (current->op != NULL)
            printf("%s\t", current->op);
        else
            printf("NULL\t");

        if (current->arg2 != NULL)
            printf("%s\t", current->arg2);
        else
            printf("NULL\t");

        if (current->nodetype != NULL)
            printf("%s\t", current->nodetype);
        else
            printf("NULL\t");

        // Print a new line for the current TAC instruction
        printf("\n");
    }
    printf("\n");
}

void printTACToFile(const char* filename, TAC* tac) {
    TAC* head = tac;
    if (!head) return;

    cleanupTAC(&head);

    FILE* file = fopen(filename , "w");
    if (!file) {
        perror("Failed to open file");
        return;
    }
    TAC* current = head;
    while (current != NULL) {
        if (strcmp(current->op,"=") == 0) {
            fprintf(file, "%s = %s\n", current->result, current->arg1);
        }
        else {
            if(current->result != NULL)
                fprintf(file, "%s = ", current->result);
            if(current->arg1 != NULL)
                fprintf(file, "%s ", current->arg1);
            if(current->op != NULL)
                fprintf(file, "%s ", current->op);
            if(current->arg2 != NULL)
                fprintf(file, "%s ", current->arg2);
            fprintf(file, "\n");
    }
        current = current->next;
    }
    fclose(file);
    printf("TAC written to %s\n", filename);
}



char* createOperand(ASTNode* node) {
    if (!node) return NULL;

    switch (node->nType) {
        // Return the string representation of the number
        case NodeType_Number: {
            char* buffer = malloc(60);
            snprintf(buffer, 60, "%d", node->number.value);     //converts the number to a string
            return buffer;
        }
        // Return the string representation of the identifier
        case NodeType_ID: {
            return node->id.name;
        }
        default:
            return NULL;
    }
}

// Function to remove nodes with NULL arg1, arg2, and op
void cleanupTAC(TAC** head) {
    if (!head || !*head) return;

    TAC* current = *head;
    TAC* prev = NULL;

    while (current != NULL) {
        TAC* next = current->next;
        // Check if current node should be removed
        if (current->arg1 == NULL && current->arg2 == NULL && current->op == NULL) {
            // Remove current node
            if (prev == NULL) {
                // If current is the head, update the head
                *head = current->next;
            } else {
                // Skip the current node
                prev->next = current->next;
            }
            // Free the node's memory
            free(current);
        } else {
            // Move prev pointer only if current node is not removed
            prev = current;
        }
        // Move to the next node
        current = next;
    }
}