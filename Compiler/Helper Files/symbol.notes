	printf("\nPARSER:\nDeclared variable: %s %s %s\n\n", $1, $2, $3); 

	printf("\nPARSER:\nPrinting symbol table\n");
	printSymbolTable(symTab);

	printf("\nPARSER:\nChecking if variable has already been declared\n");
	symbol = lookupSymbol(symTab, $2);

	if (symbol != NULL) {	// Check if variable has already been declared
									printf("PARSER: Variable %s at line %d has already been declared - COMPILATION HALTED\n", $2, yylineno);
									exit(0);
								} else {	
										// Variable has not been declared yet	
										// Create AST node for VarDecl

										//$$ = malloc(sizeof(ASTNode));
										//$$->type = NodeType_VarDecl;
										//$$->varDecl.varType = strdup($1);
										//$$->varDecl.varName = strdup($2);
										// Set other fields as necessary

										// Add variable to symbol table
										addSymbol(symTab, $2, $1);
										printSymbolTable(symTab);
									}









| error ASSIGN { 
		printf("Invalid declaration near '%s'. Expecting format (INT/FLOAT) ID SEMICOLON.\n\n", yytext); 
		exit(1);
		yyerrok; }







symbol = lookupSymbol(symTab, $1);

	if (symbol == NULL) {	
		printf("SYMBOL TABLE ERROR:\nVariable %s at line %d has not been declared yet - COMPILATION HALTED\n\n", $1, yylineno);
		exit(0);
	}
	else
	{
		$$ = createAssignmentNode(createIDNode($1), $3);
	}








Declaration: Type ID SEMICOLON {  

	if(printSymbolDebug == 1)
	{
		printSymbolTable(symTab);
	}

	symbol = lookupSymbol(symTab, $2);

	if (symbol != NULL) {	
		printf("SYMBOL TABLE ERROR:\nVariable %s at line %d has already been declared - COMPILATION HALTED\n\n", $2, yylineno);
		exit(0);
	} 
	else {	
		$$ = createDeclarationNode($1, createIDNode($2));

		// Add variable to symbol table
		addSymbol(symTab, $2, $1->id.name);
		if(printSymbolDebug == 1)
		{
			printSymbolTable(symTab);
		}
	}
}
	|
	error ASSIGN{
		printf("\nPARSER ERROR:\nInvalid declaration near '%s'. Expecting format (INT/FLOAT) ID SEMICOLON.\n", yytext);
		
		exit(0);
	};




        // Expression
        case NodeType_Term: {
            TAC* leftTAC = generateTAC(expr->expr.left); 
            TAC* rightTAC = generateTAC(expr->expr.right);

            instruction->arg1 = leftTAC->result; 
            instruction->arg2 = rightTAC->result;
            instruction->op = "*";           
            instruction->result = "t0";           

            break;
        }
        // Assignment
        case NodeType_Assignment: {
            TAC* exprTAC = generateTAC(expr->assignment.expr); 

            instruction->arg1 = exprTAC->result;
            instruction->op = "=";
            instruction->arg2 = NULL;      
            instruction->result = "x";

            break;
        }
        // Print
        case NodeType_Print: {
            TAC* exprTAC = generateTAC(expr->print.expr); 

            instruction->arg1 = exprTAC->result;
            instruction->op = "print";
            instruction->arg2 = NULL;
            instruction->result = NULL;

            break;
        }






case NodeType_Expr: {
            TAC* leftTAC;
            TAC* rightTAC;

            if(expr->expr.left != NULL) {
                leftTAC = generateTAC(expr->expr.left);
                instruction->arg1 = leftTAC->result; 
            } else
                instruction->arg1 = NULL;

            if(expr->expr.right != NULL) {
                TAC* rightTAC = generateTAC(expr->expr.right);
                instruction->arg2 = rightTAC->result; 
            } else
                instruction->arg2 = NULL;

            instruction->op = "+";

            if(rightTAC != NULL) {          
                instruction->result = createTempVar();
            } else
                instruction->result = leftTAC->result;

            break;
        }




int x;
int y;
int a;
int b;
int c;
x = 1;
a = 12;
b = 23 + 10;
x = a * 1;
x = a + a + 1;
y = x + a + b + c + a + 5;
print(x);
print(y);